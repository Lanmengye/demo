## <a name="catalog">目录</a>
- [变量与常量](#title1)
- [数据类型与类型转换](#title2)
- [运算符](#title3)
- [流程控制](#title4)
- [控制台输入和输出](#title5)
- [数组](#title6)
- [函数](#title7)


## <a name="title1">[变量与常量](#catalog)</a>     
**变量**是经过计算机赋值在内存中其值可以改变的量。**常量**在程序运行期间，其值是不能改变的。       
**变量命名规范：**     
- 必须以字母或下划线开头。
- 只能由字母、数字、下划线组成，不能包含空格、标点符号、运算符及其他符号。
- 不能使用关键字。     
   **变量的声明**：
		1. 指定变量要包含的数据的类型
		2. 为它分配标识符（变量名）    
		    
变量都要先声明再**赋值**，然后才能使用（在类中直接声明的变量叫做类的成员变量，类的成员变量声明以后可以不赋初值，因为会有默认值。在方法中声明的变量叫做局部变量，局部变量使用之前必须声明并赋值）。    
**常量的声明**要使用关键字```const```并指定其数据类型、常量名及初始值。
     
变量的类型大致分为3种：     
	1. 实例变量    
  不带任何关键字声明的变量称为实例变量。实例变量在其所在的方法调用结束后，其数据将会被清除掉，所占的内存空间也会被释放。
	2. 静态变量   
  使用“static”关键字修饰的变量称为静态变量，静态变量在函数调用结束后仍保留变量值，直到程序结束前一直存在。另外，静态变量不能再类的方法中定义。
	3. 局部变量
  局部变量是指在一个独立的代码块中声明的变量，它只在这个代码块中有效，一旦离开这个范围，将不再存在。

## <a name="title2">[数据类型与类型转换](#catalog)</a>
### 数据类型
一个变量声明所指定的数据的类型称为**数据类型**。
1. 整型   
C#支持8种整型：sbyte、byte、short、ushort、int、uint、long、ulong   
2. 浮点型  
C#支持3种浮点型：float、double、decimal  
3. 布尔型  
布尔型的取值为true或false
4. 字符型  
C#的字符型可以保存单个字符的值，在C#中，char类型的值需要放在单引号中。
5. 字符串型   
C#中的字符串类型可以包含多个字符组成的字符串，字符串类型的值需要放在双引号中。   
- 字符串一旦被创建就不可修改。
- 字符串暂存池（默认只针对字符串常量）。
格式化字符串：{索引[,对齐][:格式字符串]}
[,number]：宽度+对齐，正整数表示右对齐，负整数表示左对齐
字符串中提供的各种方法：
  - ```Length```：获得当前字符串中字符的个数
  - ```ToUpper()```：将字符串转换成大写形式
  - ```ToLower()```：将字符串转换成小写形式
  - ```Equals(str1,StringComparison.OrdinalIgnoreCase)```：比较两个字符串，可以忽略大小写
  - ```Split()```：分割字符串，返回字符串类型的数组
  - ```Substring()```：截取字符串，在截取的时候包含要截取的那个位置
  - ```IndexOf()```：判断某个字符串在字符串中第一次出现的位置，如果没有返回-1
  - ```LastIndexOf()```：判断某个字符串在字符串中最后一次出现的位置，如果没有返回-1
  - ```StartWith()```：判断以…开始
  - ```EndsWith()```：判断以…结束
  - ```Replace()```：将字符串中某个字符串替换成一个新的字符串
  - ```Contains()```：判断某个字符串是否包含指定的字符串
  - ```Trim()```：去掉字符串中前后的空格
  - ```TrimEnd()```：去掉字符串中结尾的空格
  - ```TrimStart()```：去掉字符串中前面的空格
  - ```IsNullOrEmpty()```：判断一个字符串是否为null或者为空
  - ```Join()```：将数组按照指定的字符串连接，返回一个字符串  
6. 枚举   
枚举类型是一种特殊的值类型，是一组已命名的数值常量，常用于声明一组命名的常数。枚举的类型必须是8个整型类型之一。枚举用关键字```enum```来声明定义。格式如下：   
```enum``` 枚举名[: 数据类型]
{ 成员1 [=整型常数1], 成员2 [=整型常数2], 成员3 [=整型常数3],…, 成员n [=整型常数n]}
没有指定特定的枚举类型，一般会默认枚举元素的基础类型为int。默认状态下，将0赋值给枚举对象的第一个元素，然后对每个后续的枚举元素按1递增。但是，也可以在初始化阶段给元素直接赋值。
7. 结构体
结构类型是一种值类型，用关键字```struct```来声明，它是一种堆栈分配的复杂数据类型，它不支持继承。结构主要用于创建小型的对象，并可以节省内存。结构可以包含构造函数、常量、字段、方法、属性、索引器、运算符、事件和嵌套类型等。 
  
### 类型转换
只有具有相同数据类型的对象才能够互相操作，为了进行不同数据类型的运算（如整型和浮点型的运算等），需要把数据从一种类型转换为另一种类型，即进行类型转换。C#有两种转换方式。
- 隐式转换：无需指明转换，编译器自动将操作数转换为相同的类型。     
当两个不同数据类型的操作数进行运算时，编译器会试图对其进行自动类型转换，使两者变为同一类型。不同的数据类型具有不同的赋值空间，如果试图将一个需要较大赋值空间的数据类型转换为赋值空间较小的数据，就会出现错误。
- 显示转换    
在C#中，为了避免隐式转换可能带来的错误，需要使用强制转换来执行显示转换，强制类型转换的形式为：(类型说明符)(待转换的数据)，其作用是把待转换的数据的类型强制转换成类型说明符所表示的数据类型。另外，C#允许使用```System.Convert```类提供的类型转换方法来转换数据类型。   
    
#### 值类型与引用类型
在C#中，根据数据类型的不同，变量存储在两个不同的位置。第一个位置是程序的堆栈，每个程序都有自己的堆栈，其他程序是不能直接访问的。在程序的方法被调用时，所有的本地变量都放入程序的堆栈，调用完毕后，变量出栈并检索。第二个位置是托管内存中的堆，在程序运行的过程中，CLR定期检查并清理堆栈中不能访问的变量，释放该变量占用的内存。存储在第一个位置的数据类型是值类型，存储在第二个位置的数据类型是引用类型。     
当值类型的变量被赋值时，在堆栈中创建的是两个相同的数据副本，其中一个变量值的改变不会引起另一个变量的改变。当引用类型的变量被赋值时，在内存堆中创建的是对同一个位置的两个引用。     

## <a name="title3">[运算符](#catalog)</a>
C#中的运算符是用来对变量、常量或数据类型进行计算的符号，它智慧计算机进行什么的操作。    
1. 算术运算符     
算术运算符是用来处理四则运算的符号，如（+、-、*、/、%、++、--）
2. 字符串运算符    
字符串运算符只有一个，就是“+”。除了作为算术运算符外，它还可以将字符串连接起来，变成合并的新字符串。
3. 赋值运算符    
赋值运算符是把其右边表达式的值赋给左边的变量或常量。
4. 逻辑运算符      
逻辑运算符通常用来测试真假值，如（==、!=、&&、||、!）
5. 位运算符       
位运算符用于做一些快速的数学运算，如（&、|、^（异或）、<<、>>、~（非））
6. 其他运算符     
```new```：创建一个类的实例
```typeof```：获取数据类型
```.```：获取对象的方法或属性
```?:```：问号表达式

## <a name="title4">[流程控制](#catalog)</a>
- 条件语句
	- ```if```语句
    1. 单分支结构
		```C#
			if(布尔（逻辑/条件）表达式)
			{	
				代码块	
			}
		```
	2. 双分支语句
		```C#
		if(布尔（条件/逻辑表达式）)
		{	
			代码块1		
		}
		else
		{	
			代码块2	
		}
		```
	3. 多分支语句
		```C#
		if(布尔（条件/逻辑表达式）)
		{
			代码块1		
		}		
		else if(布尔（条件/逻辑表达式）)
		{	
			代码块2		
		}
		else
		{	
			代码块3	
		}
		```
 
	- ```switch```语句   
	```switch```语句具有以下几个组成部分：
		1. 初始的```switch```语句。这条语句在圆括号中包括要测试的值。
		2. 大括号括住了```switch```语句的内容，与函数或if语句相似。
		3. 一条或多条```case```语句，其中每条语句都指定了一个值，以此比较在```switch```语句中指定的值。如果值匹配，就会执行```case```语句后面的语句。否则，就会尝试下一个```case```。
		4. ```break```语句用于结束每一个```case```。这将跳到```switch```的末尾。如果没有包括```break```，可能会执行多个```case```中的语句，而不管它们是否匹配。
		5. 可以选择包括```default```情况，其中接着一条或多条语句，如果其他```case```都不匹配，则将执行这些语句。
	- 问号表达式    
   语法格式：```variable=(condition)?(value if true):(value if false);```
   如果条件为真，将会使用问号（?）后面的值；如果条件为假，则会使用冒号（：）后面的值。
- 循环语句
	- ```for```语句    
   for循环有3个参数，它们之间用分号隔开。
		1. 第一个参数指定一个变量，并赋予它一个初始值。这称为初始表达式（initial expression），因为它建立了循环的初始状态。
		2. 第二个参数是一个条件，要使循环持续运行，它就必须保持为真。这称为循环的条件（condition）。
		3. 第三个参数是一条随同循环的每次迭代而执行的语句。这称为递增表达式（increment expression），因为它通常用于递增计数器。递增表达式是在每次循环迭代的末尾执行的。
   在指定了三个参数之后，使用左大括号（{）指示代码块的开始，并在代码块的末尾使用右大括号（}）。在循环的每次迭代中，都将执行大括号之间的所有语句。
	- ```foreach```语句            
   凡是具有```GetEnumerator()```这个方法的类型都能使用```foreach```来遍历。其实通过```foreach```遍历数据，实际上是调用了一个“枚举器”来遍历数据，和```foreach```一点关系都没有，```foreach```只是一个语法上的简化而已。希望一个类被“枚举”、“遍历”，就要实现类，该类是一个“枚举器”。
	- ```while```语句
   ```while```语句在圆括号中包括条件，其后接着大括号内的语句块。当条件成立时执行代码块。
	- ```do……while```语句
  ```do```后接着大括号的代码块，之后接```while```条件，它与```while```的区别是：```do……while```环的条件是在循环的末尾（而不是开头）测试的。```do…while```语句无论条件是否成立，代码块至少都会执行一次。
	- ```break```语句退出循环
   当程序遇到```break```语句时，它将会跳过循环的其余部分，并继续执行脚本中的循环末尾的右大括号后面的第一条语句。
	- ```continue```语句继续执行
   ```continue```语句会跳过循环中的其余部分，但是与```break```语句不同的是，它会继续执行循环的下一次迭代。
	- ```return```语句控制循环
   ```return```语句主要用于结束函数的执行，并可以将需要的参量返回。可以用于包括循环语句在内的函数中的任何地方。

## <a name="title5">[控制台输入和输出](#catalog)</a>
输入：
```Console.ReadLine()```：输入（换行）
```Console.Read()```：输入（不换行）当前位置索引的字符，返回ASCII编码，int类型
输出：
```Console.WriteLine()```：输出（换行）
```Console.Write()```：输出（不换行）

## <a name="title6">[数组](#catalog)</a>
1. 内存地址 ：计算机为了识别 每一个内存空间。 给每一个字节的空间都有一个编号。
2. 变量的地址：变量在计算机中占有的所有空间（多个字节）中的第一个字节的地址。
3. 数组
(1)	一片连续的内存空间。
(2)	可以存放多个数据 。
(3)	数组存放的数据是有序的。
(4)	数组的大小是用户指定的。
(5)	数组在内存中占有两片空间：一片小空间存放大空间的首地址，大空间中存放的是数据。
(6) 数组是由多个变量组合而成 。
4. 定义数组 
```C#
(1)	int[] array  = new int [10] ; 
(2)	int[] array  = new int [7]  { 74,   87  ,59,  65,  14,  30, 69 };
	int[] array  = new int [ ]  { 74,   87  ,59,  65,  14,  30, 69 };
	int[] array  =  { 74,   87  ,59,  65,  14,  30, 69 };
(3)	int[] array  = new int [10] ; 
	array [0] = 75;
	array [3] = 88;
```
5. 数组元素：数组中存放的每一个值 ，功能等价于一个变量 。
6. 下标 ：数组的下标是固定从0 开始的正整数，下标的范围：[ 0 , array.Length-1 ]	
7. 数组中的元素总个数：```array.Length```
8. 数组名：就是数组的【首地址】

## <a name="title7">[函数](#catalog)</a>
1. 概念
	1. 是一个独立的功能模块
	2. ```function``` 
	3. 主函数```Main()``` : 程序的入口，计算机每次只执行主函数中的代码 
	4. 除主函数以外的其他函数，计算机都不会自动执行，除非调用 ！！！
2. 函数的组成部分
	1. 函数名称
	2. 函数的参数   ： 函数的圆括号中的变量或者值 。
	3. 函数的返回值 ： 函数计算之后的结果 
3. 函数的分类 ：（ 接触的函数 ）
	1. 无参数、无返回值	```Console.WriteLine();```
	2. 无参数、有返回值	```string str = Console.ReadLine();```
	3. 有参数、无返回值	```Console.Write("hello");```
	4. 有参数、有返回值	```int a = int.Parse("159");```
4. 定义函数：创造一个本来不存在的函数的过程 。
	- 语法说明     
		```C#    
		static 返回类型 函数名称 (形参列表)   
		{
			// 函数体...
		}
		```
	- 实例 
		```C#
		static int Sum(  int a   , int b )
		{
			return  a + b ;
		}
		```
5. 调用函数 
	- 语法说明	```变量 = 类名称.函数名称( 实参列表 );```
	- 实例	```int m = Demo03.Sum(2,7);```
6. 函数的参数
	- 形参 ：
		1. 在【定义函数】时指定 
		2. 形参就是变量，但是他的值来自于实参（  实参给他啥，他就接受啥！ ）
		3. 形参之间使用逗号( , )分割 
	- 实参 ：
		1. 实参是在【调用函数】时指定
		2. 实参可以是数字、也可以是变量（ 必须有值 ）
		3. 实参将他的值传递给形参！
		4. 实参的传递顺序、个数、数据类型必须和形参一致 
	- 传参方式
		1. 按【值】传参：	 
  形参和实参占用的内存空间是彼此独立的，形参被改变不会影响到实参值。
		2. 按【地址】【引用】传参
  形参和实参指向的是同一片内存空间，形参被改变会影响到实参的值。
7. 函数的返回值
	- 所有函数都有返回值，只是有的函数可能返回 void 类型 
	- 如果函数的返回类型不是void，那么就必须在函数中使用关键字 return，返回需要的值。
	- 三个关键字
		- ```continue```：只退出本次循环，继续下一次循环
		- ```break```：强制退出整个循环语句（ 一层循环 ）
		- ```return```：强制退出函数（后续代码一概不执行！）
	- 函数的返回类型：函数定义时的类型指定 
	- 函数一旦定义需要有返回值的话 ，那么就必须保证无论代码中的条件是否成立 都应该有返回值！ 
8. 递归函数 
