TPL(Task Parallel Library，任务并行库)     
PLINQ(Parallel LINQ，并行LINQ)     
TAP( Task-based Asynchronous Pattern，基于任务的异步模式)    

目录
1. [多线程处理](#title1)
	1. [多线程基础](#point1)
	2. [使用System.Threading](#point2)
	3. [异步任务](#point3)
	4. [取消任务](#point4)
	5. [C#5.0基于任务的异步模式](#point5)
	6. [并行迭代](#point6)
	7. [并行执行LINQ查询](#point7)
2. [线程同步](#title2)
---

# <a name="title1">多线程处理</a>

<a name="point1">1. 多线程基础   </a>
---
- 多线程术语
	- 进程、线程、单线程、多线程
	- 线程安全、线程处理模型、任务、线程池
	
- 多线程处理的目的和方式    
多线程处理主要用于两个方面：实现多任务和解决延迟。    
操作系统以极快的速度从一个线程切换到另一个线程。处理器在切换到另一个线程之前，执行一个特定线程的时间周期成为时间片或量子。在一个给定的内核中改换执行线程的动作称为上下文切换。    
并行编程是指将一个问题分解成较小的部分，并异步地发起对每个部分的处理，使它们能并发地得到处理。

- 性能问题
上下文切换的开销
	- 线程处理的问题
	1. 大多数操作不是原子性的
	2. 竞态条件所造成的不确定性
	3. 内存模型的复杂性
	4. 锁定造成死锁

<a name="point2">2. 使用```System.Threading```</a>   
---
1. 使用```System.Threading.Thread```进行异步操作     
代码为了在不同线程的上下文中运行，需要```ThreadStart```或者```ParameterizedThreadStart```类型的一个委托来标识要执行的代码（后者允许单个object类型的参数）。给定用```ThreadStart```委托构造器创建的一个```Thread```实例，可调用```thread.Start```来启动线程。

2. 线程管理
- ```Join()```：可以调用```Join()```使一个线程等待另一个线程。它告诉操作系统暂停当前线程，直到另一个线程终止。
- ```IsBackGround```：新线程默认为“前台”线程；操作系统将在进程的所有前台线程完成后终止进程。可将```thread.IsBackGround```属性设为true，从而将线程标记为“后台”线程。这样，即使后台线程仍在运行，操作系统也允许进程终止。
- ```Priority```：设置线程的优先级
- ```ThreadState```：查看线程的状态

 3. 在生产代码中不要让线程进入睡眠    
静态方法 ```Thread.Sleep()```使当前线程进入睡眠——其实就是告诉操作系统在指定时间内不要为该线程调度任何时间片。睡眠的线程是不运行代码的。       
线程睡眠的目的通常是和其他线程就某个事件进行同步。但是，操作系统不保证计时的精确度。

 4. 在生产代码中不要中止线程    
```Thread```对象的```Abort()```方法一旦执行，就会尝试销毁线程。它造成“运行时”在线程中引发```ThreadAbortException```异常。该异常可被捕获，但即使被捕获并被忽略，都会自动重新引发以确保线程事实上被销毁。不要中止线程的原因是多方面的：
	- 方法只是承诺尝试中止线程，不保证成功。
	- 被中止的线程可能正在执行有```lock```语句保护的关键代码。
	- 线程中止时，CLR保证自己的内部数据结构不会损坏，但BCL没有做出这个保证。在错误的时间引发异常，中止线程可能使你的数据结构或者BCL的数据结构处于损坏状态。在其他线程或者中止线程的finally块中运行的代码可能看到损坏的状态，要么崩溃，要么行为错误。   
	
 5. 线程池处理          
针对线程上下文切换的开销问题，BCL提供了线程池。开发人员不是直接分配线程，而是告诉线程池想要完成什么工作。工作结束后，线程不是中断并被销毁，而是回到池中，从而节省了当更多的工作来临时还要分配新线程的开销。     
如果多个不同的作业异步执行，线程池能在单处理器和多处理器计算机上获得更好的执行效率。效率是通过重用线程（而不是每个异步调用都在重新构造线程）来获得的。     
线程池不提供对正在执行给定工作的线程的引用。这就阻止了发出调用的线程通过前面描述的线程管理功能与工作者线程同步（或者控制工作者线程）。     

<a name="point3">3. 异步任务</a>
---
多线程编程的复杂性主要反映在以下几个方面：     
	1. **监视异步操作的状态，知道它在何时完成。** 为了判断一个异步操作于何时完成，最好不要采取轮询线程状态的办法，也不要采取阻塞并等待的办法。    
	2. **线程池。** 线程池避免了启动和终止线程的巨大开销。此外，线程池避免了创建太多的线程，防止系统将大多数时间花在线程的切换上而不是线程的运行上。    
	3. **避免死锁。** 在避免死锁的同时，防止数据同时被两个不同的线程访问。     
	4. **为不同的操作提供原子性并同步数据访问。** 为不同的操作组（指令序列） 提供同步，可以确保将一系列操作作为一个整体来执行，并可由另一个线程恰当地中断。锁定机制防止两个不同的线程同时访问数据。    
1. 从```Thread```到```Task```
在```.NET Framework4```中，TPL不是每次开始异步工作时都创建一个线程，而是创建一个Task，并告诉**任务调度器**有异步工作要执行。此时任务调度器可能采取多种策略，但默认是从**线程池**请求一个工作者线程。线程池会自行判断怎么做最高效。可能在当前任务结束后再运行新任务，也可能将新任务的工作者线程调度到特定处理器上。线程池还会判断是创建一个全新进程，还是重用一个之前已经结束运行的现有线程。      
通过将异步工作的概念抽象到Task对象中，TPL提供了一个能代表异步工作的对象，还提供了相应的API以便与工作进行交互。通过提供代表工作单元的对象，TPL使我们能通过编程将小任务合并成大任务，从而建立起一个工作流程。

2. 理解异步任务
启动任务将从线程池获取一个新线程，创建第二个“控制点”，并在那个线程上继续执行委托。主线程上的控制点和平常一样，从启动任务的调用（```Task.Run()```）之后继续。      
调用```Task.Run()```方法之后，作为参数传递的Action几乎立即开始执行。这称为“热”任务，即已触发并开始执行。“冷”任务则相反，它需要在显式触发后才开始异步工作。      
调用```Task.Wait()```将强迫主线程等待分配给任务的所有工作结束执行。使用```Task.WaitAll()```和```Task.WaitAny()```方法来实现的。可以等待一组任务完成，或者等待其中一个任务完成，当前线程才能继续。       
如果任务中执行的工作要返回结果，可以使用```Task<T>```类型来异步运行一个```Func<T>```。以同步方式执行委托时，除非获得结果，否则控制不会返回。异步执行```Task<T>```时,可以从一个线程中轮询它，看它是否完成（```IsCompleted```），若完成就获取结果(```Result```)。       

3. 任务延续     
控制流决定了接着要发生什么。“接着发生的事情”就是一个**延续**。
在普通的C#程序中，给定代码的延续会在那个代码完成后立即执行。任何给定的代码实际上都有两个可能的延续：“正常”延续和“异常”延续。如果当前代码引发异常，执行的就是后者。      
异步方法调用（比如开始一个Task）会为控制流添加一个新的维度。执行异步Task调用，控制流立即转到```Task.Start()```之后的语句。与此同时，Task委托的主体也开始执行。换言之，在涉及异步任务的时候，“接着发生的事情”是多维的。发生异常时的延续仅仅是一个不同的执行路径。相反，异常延续是多了一个并行的执行路径。     
异步任务使我们能将较小的任务合并成较大的任务，只需要描述好异步延续就可以了。通过操作延续，可以将多个任务合并到一起。可以使用```ContinueWith()```方法实现。使用```ContinueWith()```“链接”两个任务，这样当先驱任务完成后，第二个任务（延续任务）自动以异步方式开始。延续任务获取一个Task作为实参，这样才能从延续任务的代码中访问先驱任务的完成状态。```ContinueWith()```方法返回一个Task，所以可以作为另一个Task的先驱使用。以此类推，可以建立起任意长度的连续任务链。同一个先驱的多个延续任务的执行顺序在编译时是不确定的。       

4. 用```AggregateException```处理```Task```上未处理的异常    
框架用```AggregateException```收集异常，并把它们当做一个异常来报告。```AggregateException```包含的异常列表通过```InnerExceptions```属性来取。可以使用```AggregateException.Handle()```方法，为```AggregateException```中的每一个异常都指定一个要执行的表达式。```Handle()```方法的重要特点在于它是一个断言，针对```Handle()```委托成功处理的任何异常，断言应返回true。任何异常处理调用若为一个异常返回false，```Handle()```方法将引发新的```AggregateException```，其中包含了这种异常构成的列表。    
每个```AppDomain```都提供了这样的一个机制，为了观察```AppDomian```中发生的未处理异常，必须添加一个```UnhandledException```事件来处理程序。无论是主线程还是工作者线程，```AppDomain```中的线程发生的所有未处理异常都会触发```UnhandledException```事件。    
	
<a name="point4">4. 取消任务</a>
---
TPL使用的是协作式取消，一种得体的、健壮的和可靠的技术来安全地取消不再需要取消的任务。支持取消的任务要监视一个```CancellationToken```对象。任务定期轮询它，检查是否发出了取消要求。
```CancellationTokenSource.Cancel()```不是“野蛮”地中止正在执行的Task。任务会继续运行，直到它检查标志，发现标志的所有者已请求取消任务，这是才会得体地关闭任务。调用```Cancel()```实际会在从```CancellationTokenSource.Token```赋值的所有取消标志上设置```IsCancellationRequested```属性。
```CancellationToken```有一个重载的```Register()```方法。通过这个方法，可以登记一个操作，在标志为已取消时调用。换言之，调用```Register()```方法将登记对应```CancellationTokenSource```的```Cancel()```上的一个侦听委托。

- ```Task.Run()```是```Task.Factory.StartNew()```的简化形式
在.NET 4.0中，获取任务的一般方式是调用```Task.Factory.StartNew()```。.NET 4.5提供了更简单的调用方式```Task.Run()```。
```Task.Factory.StartNew()```用于调用一个要求创建额外线程的CPU密集型方法。要用```TaskCreationOptions```控制任务，要指定其他调度器，或者出于性能的考虑要传递对象状态，就可以考虑```Task.Factory.StartNew()```。只有需要将创建和调度分开，才可以考虑在构造器调用之后添加一个```Start()```调用。

- 长时间运行的任务
线程池假定所有工作都是处理器受限的，而且运行时间都比较短。这些假设的目的是控制创建的线程数量，防止因为过多分配昂贵的线程资源以及超额预订处理器而造成过于频繁的上下文切换和时间分片。
但是，如果知道一个任务要长时间运行，就可以通知调度器任务不会太快结束工作。这个通知有两方面的作用：首先，它提醒调度器或许应该为该任务创建专用线程（而不是使用来自线程池的）。其次，它提醒调度器可能应该调度比平常更多的线程。为此要在```StartNew()```时使用```TaskCreationOptions.LongRunning```选项（```Task.Run()```不支持```TaskCreationOptions```参数）

- 对任务进行资源清理
在既没有调用```Dispose()```又没有使用```using```语句的情况下，代码是依赖程序退出时的一个自动的```WaitHandle```终结器调用。这会导致两个结构：首先，句柄存活时间变长，因此会消耗更多资源。其次，垃圾回收器的效率变低了，因为被终结的对象存活到了下一代。但在使用```Task```的情况下，除非要终结大量任务，否则这两方面问题都不大。

<a name="point5">5. C#5.0基于任务的异步模式</a>
---
1. 以同步方式调用高延迟操作
同步方式调用高延迟操作的问题在于调用线程会被阻塞，直至高延迟操作结束。异步工作进行期间，线程被白白浪费了，它本可以做一些更有用的工作（如显示进度）。

2. 使用TPL异步调用高延迟操作
异步操作的代价是复杂性的增加。异步任务的延续要求调用```ContinueWith()```方法，再延续执行一个任务时需要调用```Unwrap()```，异常处理需要用```AggregateException()```捕获。

3. 通过```async```和```await```实现基于任务的异步模式
```async```关键字最主要的作用就是：（1）向阅读代码的人说清楚说明它所修饰的方法将自动由编译器重写； （2）告诉编译器方法中的上下文关键字```await```要被视为异步控制流，不能当成普通的标识符。

4. 异步Lambda
```async Lambda```表达式具有和具名```async```方法一样的限制：
	- ```async Lambda```表达式必须转换成返回类型为```void```、```Task```或```Task<T>```的委托。
	- ```Lambda```进行了重写，是```return```语句称为“```Lambda```返回的任务已经完成并获得给定结果“的信号。
	- ```Lambda```表达式中的执行最初是同步进行的，直到遇到第一个针对“未完成的可等待任务”的```await```为止。
	- ```async```之后的指令作为被调用异步方法所返回的任务的延续而执行。但假如可等待任务已经完成，就以同步方式执行而不是作为延续。
	- ```async Lambda```表达式可用```await```调用。
注意点：
	- 控制抵达```await```关键字时，后面的表达式会生成一个任务。控制随即返回调用者，在任务异步完成期间，继续做自己的事情。
	- 任务完成后的某个时间，控制从```await```之后的位置恢复。如果等待的任务生成结果，就获取那个结果。出错则引发异常。
	- ```async```方法中的```return```语句造成与方法调用关联的任务变成```已完成```状态。如果```return```语句有一个值，返回值成为任务的结果。

5. 任务调度和同步上下文     
任务调度器是```System.Threading.Task.TaskScheduler```的实例，该类默认用线程池调度任务，决定如何安全有效地执行它们——何时重用、何时进行资源清理以及何时创建额外的线程。可以获取```TaskScheduler```，使用静态方法```FromCurrentSynchronizationContext()```将任务调度给当前线程（更准确地说，调度给和当前线程关联的同步上下文），而不是调度给不同的工作者线程。用于执行任务（进而执行延续任务）的同步上下文之所以重要，是因为正在等待的任务会查询同步上下文（如果有的话）才能高效和安全地执行。

6. ```async/await```和Windows UI    
第一，TPL不是立即执行延续任务，而是查询同步上下文，将关于延续工作的消息发送给消息泵。    
第二，UI线程监视消息泵，获得延续工作消息后，它调用await调用之后的代码。（结果是延续代码在和处理消息泵的调用者一样的线程上调用。）

7. ```await```操作符      
方法中的await数量不限。事实上，它们并非只能一个接着一个写。相反，可以将await放到循环中连续处理，从而遵循一个自然的控制流。注意，无论将await放到循环中，还是单独地写，它们都会连续地、一个一个地执行，而且顺序和从调用线程中调用的顺序一样。底层实现是用语义上等价于```Task.ContinueWith()```的方式把它们串接到一起，只是await操作符之间的代码全都在调用者的同步上下文中执行。

总结：TAP的目的是解决一下关键问题
- 需要在不阻塞UI线程的前提下，允许进行长时间运行的活动。
- 为非CPU密集型的工作创建新线程（或Task）代价相当高，因为线程唯一做的事情就是傻等活动完成。
- 活动完成时（不管是使用新线程还是通过回调），经常都需要执行一次线程同步上下文切换，以返回当初发起活动的调用者。
- TAP提供了一个赞新的模式，同时支持CPU密集型和非CPU密集型的异步调用。所有.NET语言都支持这种模式。    

<a name="point6">6. 并行迭代</a>
---
```Parallel.For()```API看起来和标准for循环相似。第一个参数是fromInclusive值，第二个是toExclusive值，最后一个是要作为循环主体执行的Action<int>。为操作使用表达式Lambda、，代码看起来和for循环差不多，只是现在每一次迭代都可以并行执行。和for循环一样，除非迭代都已完成，否则```Parallel.For()```调用不会结束。      
TPL使用和任务调度一样的线程池技术来确保并行循环的良好性能，即确保CPU不被过度调度或者调度不足。        
取消并行循环：任务需要显示调用才能阻塞直至完成。而并行循环以并行方式执行迭代，但除非整个并行循环完成（全部迭代都完成），否则它本身不会返回。所以，为了取消并行循环，调用取消请求的那个线程通常不能是正在执行并行循环的那个线程。       
并行循环使用了和任务一样的取消标志模式。从一个```CancellationTokenSource```获取的标志通过调用```ForEach()```方法的一个重载版本与并行循环关联。该重载版本要获取一个```ParallelOptions```类型的参数（该对象包含取消标志）。      

<a name="point7">7. 并行执行LINQ查询</a>
---
使用并行LINQ API（简称PLINQ）并行执行LINQ查询：要实现并行支持，只需使用.NET Framework 4引入的标准查询操作符```AsParallel()```，它是由静态类```System.Linq.ParallelEnumerable```提供的。这个简单的扩展方法告诉“运行时”可以并行执行查询。如果计算机有很多处理器，查询的完成速度将快很多。    
PLINQ支持取消请求模式，取消的PLINQ查询会引发```System.OperationCanceledException```，而且PLINQ查询是在调用线程上执行的同步操作。因此，常用的技术是将并行查询包装到在另一个线程上运行的任务中，使当前线程能在必要时取消它。      
和并行循环/任务一样，取消PLINQ查询需要一个```CancellationToken```，它由```CancellationTokenSource.Token```属性提供。然而，不是重载每一个PLINQ查询来支持取消标志，而是```IEnumerable```的```AsParallelI()```方法返回的```ParallelQuery<T>```对象包含一个```WithCancellation()```扩展方法，它获取一个```CancellationToken```参数。因此，在```CancellationTokenSource```对象上调用```Cancel()```就会请求并行查询取消——因为它会检查```CancellationToken```的```IsCancellationRequested```属性。

---
# <a name="title2">线程同步</a>
<a name=point8>1. 为什么要同步</a>
---
多个线程同时访问相同的数据元素，可能破坏数据的完整性。若能同步多个线程对代码或数据的并发访问，就说这些代码和数据是**线程安全**的。
	1. 使用```Monitor```来同步 
为了同步多个线程，防止它们同时执行特定的代码段，需要用监视器来阻止第二个线程进入受保护的代码段，直到第一个线程退出那个代码段。监听器功能由```System.Threading.Monitor```类提供。为了标识受保护代码段的开始和结束位置，需要分别调用静态方法```Monitor.Enter()```和```Monitor.Exit()```。
```Monitor```支持```Pulse()```方法，它允许线程进入“就绪队列”，指出下一个就轮到它获得锁（并可以开始执行）。
	2. 使用```lock```关键字
由于多线程代码中要频繁地使用```Monitor```来进行同步，同时```try/finally```块容易被人遗忘，所以C#提供了特殊的关键字```lock```来处理这种锁定同步模式。
对象设计的“最佳实践”是对可变的静态状态进行同步（永远不变的东西不必同步），但不要同步实例数据。如果允许多个线程访问一个特定的对象，那么必须为对象提供同步。任何类如果要显式地和线程打交道，通常应该保证实例在某种程度上是线程安全的。
	3. ```lock```对象的选择
假如数据是公共的，那么同步对象可能是公共的，造成其他类能用同一个同步对象实例来进行同步。这将使得死锁更难以避免。幸好，对这个模式的需求很少。对于公共数据，更好的做法是完全在类的外部进行同步，允许调用代码为它自己的同步对象获取锁。
	4. 为什么要避免锁定```this```,```typeof(type)```和```string```
如果使用```this```，可以为一个特定对象实例关联的偶有状态提供一个同步目标；如果使用```typeof(type)```，则可以为一个类型的所有静态数据提供一个同步目标。但这样做的问题在于，在另一个完全不相干的代码块中，可能创建一个完全不同的同步块，而这个同步块的同步目标可能就是```this```（或者```typeof(type)```所指向的同步目标）。换言之，虽然只有实例自身内部的代码可以使用```this```关键字来阻塞，但创建实例的调用者仍可将那个实例传给一个同步锁。    
结果就变成了对两套不同的数据进行同步的两个同步块可能互相堵塞对方。虽然看起来不太可能，但是共享同一个同步目标可能影响性能，极端的时候甚至会造成死锁。所以，请不要在```this```或者```typeof(type)```上锁定。更好的做法是定义一个私有只读字段，除了能访问它的那个类之外，没有谁能在这个字段上堵塞。        
要避免的另一个锁定类型是```string```，这是因为要考虑到字符串拘留问题。如果同一个字符串常量在多个位置出现，那么所有位置都可能引用同一个实例，使锁定的范围大于预期。
	5. 将字段声明为```volatile```
```volatile```修饰符指出字段容易被硬件、操作系统或者另一个线程修改。所以，这种数据是“易变的”，编译器和“运行时”要更加严谨地处理它。
	6. 使用```System.Threading.Interlocked```类
```Interlocked.CompareExchange()```方法内建了同步机制，它同样会检查```null```值，如果值等于第二个参数的值，就更新第一个参数。
	7. 多个线程时的事件通知
如果委托可能由多个线程同时访问，就需要对委托的赋值和触发进行同步。
	8. 同步设计最佳实践
		1. 避免死锁
同步的引入带来了死锁的可能。两个或更多的线程都在等待对方释放一个同步锁，就会发生死锁。
死锁的发生必须满足以下4个基本条件：
- 排他或互斥：一个线程独占一个资源，没有其他线程能获取相同的资源     
- 占有并等待：互斥的一个线程请求获取另一个线程占有的资源    
- 不可抢先：一个线程占有的资源不能被强制拿走（只能等待线程主动释放它锁定的资源）
- 循环等待条件：两个或多个线程构成一个循环等待链，它们锁定两个或多个相同的资源，每个线程都在等待链中的下一个线程占有的资源。
		2. 何时提供同步
所有静态数据都应该确保线程安全。所以，同步需要围绕静态数据来进行。通常，这意味着程序员应该声明私有静态变量，并提供公共方法来修改数据。这些方法在内部应处理好同步问题。
相反，实例数据不需要包含同步机制。同步会显著降低性能，并增大夺取锁或者死锁的概率。除了显式设计成由多个线程访问之外，程序员在多个线程中共享对象应当针对要共享的数据，解决好它们自己的同步问题。
		3. 避免不必要的锁定
在不破坏数据完整性的前提下，同步能避免的就要尽量避免。类似地，避免锁定本来就是线程安全的操作。
	9. 更多的同步类型
		1. ```System.Threading.Mutex```
		2. ```WaitHandle```    
		3. 事件重置类： ```ManualResetEvent```和```ManualResetEventSlim```
		4. ```Semaphore/SemaphoreSlim```和```CountdownEvent```
		5. 并发集合类
	10. 线程本地存储
同步的一个替代方案是隔离，而实现隔离的一个办法就是使用线程本地存储。利用线程本地存储，线程就有了专属的变量的实例。
- ```ThreadLocal<T>```
- 用```ThreadStaticAttribute```提供线程本地存储      

<a name=point8>2. 计时器</a>
---
有时需要将代码的执行退后一段时间，或者在指定时间后发出通知。实现计时器的一个方式是利用C#5.0的```async/await```模式和.NET 4.5加入的```Task.Delay()```方法。